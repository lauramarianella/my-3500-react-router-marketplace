import './App.css'; /* 1 */
import React, { Component } from 'react'; /* 1 */
import { Route, BrowserRouter } from 'react-router-dom' /* 1 */
import Seller from './Seller.jsx' /* 1 */
import Item from './Item.jsx' /* 1 */
import { initialItems, initialSellers } from './Data.js' /* 1 */

let renderAllItems = () => {  /* 4 */
  return <div> {/* 4 */}
    {initialItems.map(item => /* 5 */
      (<Item /* 5 */
        cost={item.price} /* 6 */
        sellerId={item.sellerId} /* 6 */
        imageLocation={item.image} /* 6 */
        description={item.description}  /* 6 */
      />))} {/* 5 */}
  </div> /* 4 */
} /* 4 */

let renderSeller = routerData => { /* 8 */
  let sellerId = routerData.match.params.sid /* 9 */
  let candidates = /* 10 */
    initialSellers.filter(seller => { return seller.id === sellerId }) /* 10 */
  return (<Seller seller={candidates[0]} />) /* 11 */
}  /* 8 */

class App extends Component { /* 1 */
  render() { /* 2 */
    return ( /* 2 */
      <BrowserRouter> {/* 2 */}
        <div> {/* 2 */}
          <Route exact={true} path='/' render={renderAllItems} /> {/* 3 */}
          <Route exact={true} path='/seller/:sid' render={renderSeller} /> {/* 7 */}
        </div> {/* 2 */}
      </BrowserRouter> /* 2 */
    ); /* 2 */
  } /* 2 */
} /* 1 */

export default App; /* 1 */
/* meta
({
  text: {
    1: `We are importing
- The css
- React
- The BrowserRouter and Route components
- The Seller and Item components we already created ourselves
- The data that will be shown to the user

Using npm, you will need to install the react-router-dom module. We also create a component and export it.
`,
    2: `The component has a render method which returns a react element. The react element is created from the BrowserRouter component.
We do this because we need to use the Route and Link components and we can only do that if they are placed under the BrowserRouter component
in the virtual DOM.`,
    3: `We create a route for the \`/\` path. If the path in the address bar matches \`/\` exactly, then the renderAllItems function is called
and the result of the function call is placed in the virtual DOM under this Route element. `,
    4: `The renderAllItems function returns a div react element. `,
    5: `The children of the div will all be Item react elements. Looking at Data.js, we see that
    initialItems has 2 elements. Therefore, the array generated by map will also have 2 elements
    (why is this?) `,
    6: `Looking at Item.jsx, we see that the item component has 4 props
- cost
- sellerId
- imageLocation
- description

(How did we come up with those 4 props?)

Therefore, we must provide these props when we create an element. Looking at Data.js, we see that each
element of the initialItems array is an object. Each of those objects has the following properties
- price
- sellerId
- image
- description

Since \`item\` is the parameter name of the function that we're passing to map, item will refer
to an element of the initialItems array every time this function is called (which is twice. Why?).
Therefore, we can use those properties to populate the props of the Item react element.
`,
    7: `We create a route for the \`/path\` path. Since the path contains the
\`:\` symbol, it is actually a path template.
Here are examples of which paths this Route will match
- /seller/akdfh
- /seller/2342
- /seller/232abc

and here are examples of paths that this route will NOT match
- /
- /sellerabc
- /sellers/abc

When the Route matches the path in the addrss bar, the renderSeller function is called
and the result of the function call is placed in the virtual DOM under this Route element.
the renderSeller function is called with an argument that contains information related
to the path in the address bar . For example, if the path in the address bar is \`/seller/abc\`
then the argument passed to renderSeller will be
\`\`\`javascript
{match: {params: {sid: abc}}}
\`\`\`

and if the path is \`/seller/def\` then the argument will be
\`\`\`javascript
{match: {params: {sid: def}}}
\`\`\`

(where does \`sid\` come from?)
`,
    8: `The renderSeller function has a single parameter that we called routerData. It will refer to the argument
that is passed to the function (by the definition of parameter). See the previous slides for examples of
what kinds of arguments are passed.`,
    9: `As a convenience, I create a variable that refers to the last part of the path in the address bar. The last
    part of the path in the address bar represents the id of the seller. Which this id, we can get the information
    related to the seller so that we can display it to the user.`,
    10: `With the id, we can use the filter function to find the seller with the id. initialSellers is a variable
    that refers to an array. The elements of that array are objects. Each object has several properties, including \`id\`
    The function that we give to filter has one parameter. The name we chose for that parameter is seller. Every time
    the function is called, seller will refer to a different object of the initialSellers array. The function returns a
    boolean. That boolean is only true if the id property of the seller matches the sellerId, which is a variable
    that refers to the last part of the path in the address bar. \`filter\` returns an array with all the sellers that match the id.
    Since the ids in Data.jsx are unique, there can be at most one element in that array. We create a variable candidates that
    refers to this array.`,
    11: `Looking at Seller.jsx, we see that it has a single seller prop. Therefore, if we want to use this component, we need
    to give it that prop. The value of the prop is the first element of the array that we created in the previous slide. If that
    array is empty, then \`candidates[0]\` will be undefined. `
  }
})
*/